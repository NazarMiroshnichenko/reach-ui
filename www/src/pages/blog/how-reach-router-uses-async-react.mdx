---
title: How Reach Router Uses Async React
---

# How Reach Router Uses Modern and Future React

I'd like to tell you about how my new project, Reach Router, takes advantage of the new features in React like Suspense, Time Slicing, and more.

## A Little Background

Async React could not come fast enough for me. There are a lot of things that folks look to a client-side router to do for them:

- Declaring data dependencies
- Pausing the old screen while the next route's data loads
- Waiting for data on the server before rendering
- Code-splitting by route
- Scroll restoration
- Focus management
- Animations
- probably more...

In React Router v3 we came up with some APIs to handle some of this stuff (`<Route onEnter/>` for data loading and `<Route getComponent/>` for code-splitting), but we had to run our code *outside* of the React render cycle, which means we had bailed out of the composition model that we love about React. That's why React Router felt different than the rest of React.

On a flight home from Chicago (with a deer tick on my body that I DID NOT KNOW WAS SUCKING MY BLOOD) I played with an [idea from Sunil Pai](https://github.com/ReactTraining/react-router/issues/3051) about how routing in React could work if we ignored all these "outside of React" use-cases. That code eventually became React Router v4. Lots of people loved it, just as many hated it, but I was happy because we were now just another part of React like any other component.

All router problems were now React problems--and React didn't have very good answers. ðŸ˜‘

With React Suspense, there are finally some good answers.

## Why Did You Make Reach Router?

Early in 2018 Andrew Clark pointed me to some of his work on React Suspense, so I built React from master and started tinkering. React Router wasn't compatible with the unreleased async mode, so I slapped together a little router just to experiment.

I used some new React APIs, made a few different design choices, and realized I could easily implement a couple features I've wanted for a long time (relative links and focus management) and bring back one I missed (nested routes) all while staying inside of React with Just Componentsâ„¢.

I ended up with a Router that felt great to use, had a solid feature set, and was pretty small at around 4kb. I wanted to use it for all of my React projects! I had a hard time deciding to publish it or not, talked to some close friends in the React and accessibility communities and decided to go ahead and publish it.

I've always approached my OSS projects in a simple way: If I want to use it then somebody else probably does, too. I think you'll like it.

Finally, I get asked why Reach Router wasn't just React Router v5. It's pretty simple, I'm not involved that with that project anymore.

## Suspense

The main thing that took routing out of "react" in React Router's early versions was the need to "pause the old screen" while we waited for data.

## Context

Reach Router uses the new `React.createContext()` heavily. The part I think is most interesting is the default argument to `createContext`.  We're accustomed to rendering a `Provider` at the top of our apps for redux, translations, and routers. But because `createContext` supports a default argument you can render a context consumer that has no parent provider!

```.jsx
(() => {
  const defaultTheme = { primary: 'blue', padding: 20 }
  const ThemeContext = React.createContext(defaultTheme)

  return (
    <ThemeContext.Consumer>
      {theme => (
        <div style={{
          color: theme.primary,
          padding: theme.padding
        }}>
          Look, ma! No Provider!
        </div>
      )}
    </ThemeContext.Consumer>
  )
})()
```

The new context made it easier for me to make relative links work well. Each Router renders a `BaseContext` that contains `context.basepath` and `context.baseuri`. The `basepath` is the path pattern to match, and the `baseuri` is the actual URI of the app. The natural nesting of routers and context made it easy to keep track of the parent's relative path that a Link is rendered within. None of this is or needs to be public API, it all just worksâ„¢.

## History Stack

In Suspense, react allows you to put data dependencies right inside of your component's render method:

```jsx
let Invoice = ({ invoiceId }) => {
  let { invoiceId } = this.props
  // right here
  let invoice = InvoiceResource.read(cache, invoiceId)
  return (
    <div>
      <h1>{invoice.number}</h1>
    </div>
  )
}
```

Suspense will wait for that invoice to load before the page is rendered, leaving the old screen up.

When a user clicks a link
